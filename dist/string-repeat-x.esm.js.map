{"version":3,"sources":["../src/string-repeat-x.js"],"names":[],"mappings":";;;;AAAA,OAAO,cAAP,MAA2B,aAA3B;AACA,OAAO,SAAP,MAAsB,cAAtB;AACA,OAAO,sBAAP,MAAmC,4BAAnC;AACA,OAAO,KAAP,MAAkB,aAAlB;AACA,OAAO,OAAP,MAAoB,WAApB;AAEA,IAAM,YAAY,GAAG,EAArB;IACe,Y,GAAgB,Y,CAAxB,M;AACP,IAAM,SAAS,GAAG,OAAO,CAAC;AAAA;;AAAA,SAAM,YAAY,CAAC,IAAb,CAAkB,GAAlB,EAAuB,CAAvB,CAAN;AAAA,CAAD,YAAP,CAAyC,KAAzC,KAAmD,OAArE;;AAEA,IAAM,aAAa,GAAG,SAAS,aAAT,GAAyB;AAC7C,SAAO,SAAS,MAAT,CAAgB,KAAhB,EAAuB,KAAvB,EAA8B;AACnC,WAAO,YAAY,CAAC,IAAb,CAAkB,sBAAsB,CAAC,KAAD,CAAxC,EAAiD,KAAjD,KAA2D,YAAlE;AACD,GAFD;AAGD,CAJD;;AAMA,IAAM,WAAW,GAAG,SAAS,WAAT,CAAqB,CAArB,EAAwB;AAC1C;AACA,MAAI,CAAC,GAAG,CAAJ,IAAS,CAAC,cAAc,CAAC,CAAD,CAA5B,EAAiC;AAC/B,UAAM,IAAI,UAAJ,CAAe,qBAAf,CAAN;AACD;;AAED,SAAO,CAAP;AACD,CAPD;;AASA,OAAO,IAAM,cAAc,GAAG,SAAS,cAAT,GAA0B;AACtD,SAAO,SAAS,MAAT,CAAgB,KAAhB,EAAuB,KAAvB,EAA8B;AACnC,QAAI,MAAM,GAAG,KAAK,CAAC,sBAAsB,CAAC,KAAD,CAAvB,CAAlB;AACA,QAAI,CAAC,GAAG,WAAW,CAAC,SAAS,CAAC,KAAD,CAAV,CAAnB;AAEA,QAAI,MAAM,GAAG,YAAb;;AACA,WAAO,CAAP,EAAU;AACR,UAAI,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AACf,QAAA,MAAM,IAAI,MAAV;AACD;;AAED,UAAI,CAAC,GAAG,CAAR,EAAW;AACT,QAAA,MAAM,IAAI,MAAV;AACD;AAED;;;AACA,MAAA,CAAC,KAAK,CAAN;AACD;;AAED,WAAO,MAAP;AACD,GAnBD;AAoBD,CArBM;AAuBP;;;;;;;;AAOA,IAAM,OAAO,GAAG,SAAS,GAAG,aAAa,EAAhB,GAAqB,cAAc,EAA5D;AAEA,eAAe,OAAf","file":"string-repeat-x.esm.js","sourcesContent":["import numberIsFinite from 'is-finite-x';\nimport toInteger from 'to-integer-x';\nimport requireObjectCoercible from 'require-object-coercible-x';\nimport toStr from 'to-string-x';\nimport attempt from 'attempt-x';\n\nconst EMPTY_STRING = '';\nconst {repeat: nativeRepeat} = EMPTY_STRING;\nconst hasNative = attempt(() => nativeRepeat.call('a', 5)).value === 'aaaaa';\n\nconst patchedRepeat = function patchedRepeat() {\n  return function repeat(value, count) {\n    return nativeRepeat.call(requireObjectCoercible(value), count) || EMPTY_STRING;\n  };\n};\n\nconst assertRange = function assertRange(n) {\n  // Account for out-of-bounds indices\n  if (n < 0 || !numberIsFinite(n)) {\n    throw new RangeError('Invalid count value');\n  }\n\n  return n;\n};\n\nexport const implementation = function implementation() {\n  return function repeat(value, count) {\n    let string = toStr(requireObjectCoercible(value));\n    let n = assertRange(toInteger(count));\n\n    let result = EMPTY_STRING;\n    while (n) {\n      if (n % 2 === 1) {\n        result += string;\n      }\n\n      if (n > 1) {\n        string += string;\n      }\n\n      /* eslint-disable-next-line no-bitwise */\n      n >>= 1;\n    }\n\n    return result;\n  };\n};\n\n/**\n * Repeat the given string the specified number of times.\n *\n * @param {string} value - The string to repeat.\n * @param {(number|string)} count - The number of times to repeat the string.\n * @returns {string} Repeated string.\n */\nconst $repeat = hasNative ? patchedRepeat() : implementation();\n\nexport default $repeat;\n"]}