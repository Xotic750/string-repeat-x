{"version":3,"sources":["../src/string-repeat-x.js"],"names":[],"mappings":"AAAA,OAAO,cAAP,MAA2B,aAA3B;AACA,OAAO,SAAP,MAAsB,cAAtB;AACA,OAAO,sBAAP,MAAmC,4BAAnC;AACA,OAAO,KAAP,MAAkB,aAAlB;AACA,OAAO,OAAP,MAAoB,WAApB;AAEA,IAAM,YAAY,GAAG,EAArB;IACe,Y,GAAgB,Y,CAAxB,M;AACP,IAAM,SAAS,GACb,OAAO,CAAC,SAAS,SAAT,GAAqB;AAC3B,SAAO,YAAY,CAAC,IAAb,CAAkB,GAAlB,EAAuB,CAAvB,CAAP;AACD,CAFM,CAAP,CAEG,KAFH,KAEa,OAHf;;AAKA,IAAM,aAAa,GAAG,SAAS,MAAT,CAAgB,KAAhB,EAAuB,KAAvB,EAA8B;AAClD,SAAO,YAAY,CAAC,IAAb,CAAkB,sBAAsB,CAAC,KAAD,CAAxC,EAAiD,KAAjD,KAA2D,YAAlE;AACD,CAFD;;AAIA,IAAM,WAAW,GAAG,SAAS,WAAT,CAAqB,CAArB,EAAwB;AAC1C;AACA,MAAI,CAAC,GAAG,CAAJ,IAAS,CAAC,cAAc,CAAC,CAAD,CAA5B,EAAiC;AAC/B,UAAM,IAAI,UAAJ,CAAe,qBAAf,CAAN;AACD;;AAED,SAAO,CAAP;AACD,CAPD;;AASA,OAAO,IAAM,cAAc,GAAG,SAAS,MAAT,CAAgB,KAAhB,EAAuB,KAAvB,EAA8B;AAC1D,MAAI,MAAM,GAAG,KAAK,CAAC,sBAAsB,CAAC,KAAD,CAAvB,CAAlB;AACA,MAAI,CAAC,GAAG,WAAW,CAAC,SAAS,CAAC,KAAD,CAAV,CAAnB;AAEA,MAAI,MAAM,GAAG,YAAb;;AACA,SAAO,CAAP,EAAU;AACR,QAAI,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AACf,MAAA,MAAM,IAAI,MAAV;AACD;;AAED,QAAI,CAAC,GAAG,CAAR,EAAW;AACT,MAAA,MAAM,IAAI,MAAV;AACD;AAED;;;AACA,IAAA,CAAC,KAAK,CAAN;AACD;;AAED,SAAO,MAAP;AACD,CAnBM;AAqBP;;;;;;;;AAOA,IAAM,OAAO,GAAG,SAAS,GAAG,aAAH,GAAmB,cAA5C;AAEA,eAAe,OAAf","file":"string-repeat-x.esm.js","sourcesContent":["import numberIsFinite from 'is-finite-x';\nimport toInteger from 'to-integer-x';\nimport requireObjectCoercible from 'require-object-coercible-x';\nimport toStr from 'to-string-x';\nimport attempt from 'attempt-x';\n\nconst EMPTY_STRING = '';\nconst {repeat: nativeRepeat} = EMPTY_STRING;\nconst hasNative =\n  attempt(function attemptee() {\n    return nativeRepeat.call('a', 5);\n  }).value === 'aaaaa';\n\nconst patchedRepeat = function repeat(value, count) {\n  return nativeRepeat.call(requireObjectCoercible(value), count) || EMPTY_STRING;\n};\n\nconst assertRange = function assertRange(n) {\n  // Account for out-of-bounds indices\n  if (n < 0 || !numberIsFinite(n)) {\n    throw new RangeError('Invalid count value');\n  }\n\n  return n;\n};\n\nexport const implementation = function repeat(value, count) {\n  let string = toStr(requireObjectCoercible(value));\n  let n = assertRange(toInteger(count));\n\n  let result = EMPTY_STRING;\n  while (n) {\n    if (n % 2 === 1) {\n      result += string;\n    }\n\n    if (n > 1) {\n      string += string;\n    }\n\n    /* eslint-disable-next-line no-bitwise */\n    n >>= 1;\n  }\n\n  return result;\n};\n\n/**\n * Repeat the given string the specified number of times.\n *\n * @param {string} value - The string to repeat.\n * @param {(number|string)} count - The number of times to repeat the string.\n * @returns {string} Repeated string.\n */\nconst $repeat = hasNative ? patchedRepeat : implementation;\n\nexport default $repeat;\n"]}